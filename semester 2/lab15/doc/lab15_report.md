# Лабораторна робота №15. STL. Вступ до Стандартної бібліотеки шаблонів(частина 2)

## 1. Вимоги

### 1.1 Розробник

- Клименко Юрій Юрійович;

- студент групи КІТ-120а;

- 05-червня-2021

### 1.2 Загальне завдання

 * **Розширити** попередню роботу, зробивши клас-список STL ітеративним. 

## 2. Опис програми 

### 2.1 Функціональне призначення

Загальне завдання виконується за допомогою розроблених методів
`begin()` та `end()`.

### 2.2 Опис логічної структури програми

_Метод:_  `begin()`: повертає початок вектору класу-контейнер
_Схема алгоритму метода `begin()`_ подана на рис. 1.
![Блок-схема](https://github.com/LiquidFunki/liquid-prog/blob/main/semester%202/lab15/doc/assests/1.png?raw=true)

Рисунок 1 --- Схема алгоритму метода`begin()`


_Метод:_  `end()`: повертає кінець вектору класу-контейнер
_Схема алгоритму метода `end()`_ подана на рис. 2.
![Блок-схема](https://github.com/LiquidFunki/liquid-prog/blob/main/semester%202/lab15/doc/assests/2.png?raw=true)

Рисунок 2 --- Схема алгоритму метода`end()`


### 2.3 Важливі фрагменти програми

#### Метод `begin()`

``` 
iterator begin(){  
    return books.begin();  
}
```
#### Метод `end()`

```
iterator end(){  
	return books.end();  
}
```
#### Демонстрація ітеративності
```
List<Book> *list;  
for(auto &book : *list){  
	book->Print();  
	cout << endl;  
}
```

### 3. Варіанти використання

Для демонстрації результатів використовується Clion. Нижче наводиться послідовність  дій запуску програми.

_Крок 1_ (рис.3 ). Демонстрація роботи ітеративності

![result1](https://github.com/LiquidFunki/liquid-prog/blob/main/semester%202/lab15/doc/assests/Screenshot_2.png?raw=true)

Рисунок 3 --- Результат виконання кроку 1


### Структура проекту

	├── lab15
	    ├── doc
	        ├── lab15.md
	        └── assets
        ├── CMakelist.txt
		└── src
		    ├── main.cpp
            ├── List.hpp
		    ├── Book.cpp
		    └── Book.h
## Висновки

Було отримано навички у роботі зі стандартною бібліотекою шаблонів, з STL-контейнерами, їх методами і функціями. Також отримали навички у роботі з ітераторами та створюванні власне ітеративних контейнери.